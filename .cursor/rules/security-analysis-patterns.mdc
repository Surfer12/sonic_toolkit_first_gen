---
globs: *PenetrationTesting*,*Security*,*Audit*,*Koopman*
description: "Security analysis patterns and penetration testing frameworks used in this research environment"
---

# Security Analysis Patterns and Penetration Testing Frameworks

This workspace implements advanced security analysis using mathematical frameworks, particularly reverse Koopman operators for system stability analysis and iOS penetration testing.

## Core Security Frameworks

### Reverse Koopman Operator Analysis

The reverse Koopman operator provides mathematical foundation for security analysis:

```swift
class ReverseKoopmanOperator {
    // Core mathematical structure for stability analysis
    private var koopmanMatrix: [[Double]] = []
    private var eigenvalues: [ComplexNumber] = []
    private var conditionNumbers: [Double] = []

    /// Analyze system stability using spectral decomposition
    func analyzeSystemStability(trajectory: [[Double]]) -> StabilityAnalysis {
        // Construct Koopman matrix from system trajectory
        koopmanMatrix = constructKoopmanMatrix(trajectory: trajectory)

        // Compute spectral decomposition
        let (eigenvalues, _) = computeSpectralDecomposition()
        self.eigenvalues = eigenvalues

        // Analyze stability properties
        let spectralRadius = eigenvalues.map { $0.magnitude }.max() ?? 0.0

        // Identify unstable modes
        let unstableModes = eigenvalues.filter { $0.magnitude > 1.0 }

        return StabilityAnalysis(
            spectralRadius: spectralRadius,
            unstableModes: unstableModes,
            conditionNumber: conditionNumbers.last ?? 0.0
        )
    }
}
```

### iOS Penetration Testing Framework

Comprehensive security assessment framework:

```swift
class iOSPenetrationTesting {
    private let reverseKoopman: ReverseKoopmanOperator
    private var findings: [SecurityFinding] = []

    /// Perform comprehensive iOS security assessment
    func performSecurityAssessment() -> [SecurityFinding] {
        // Analyze system behavior using koopman operators
        analyzeSystemBehavior()

        // Test various security aspects
        testInsecureStorage()
        testNetworkSecurity()
        testAuthenticationMechanisms()
        testMemoryManagement()

        return findings
    }
}
```

## Security Analysis Patterns

### 1. System Behavior Analysis

**Pattern**: Use dynamical systems theory to detect anomalous behavior

```swift
private func analyzeSystemBehavior() {
    print("Analyzing system behavior with reverse koopman operators...")

    // Generate system state trajectory
    let trajectory = reverseKoopman.generateVanDerPolTrajectory(nPoints: 1000)

    // Construct koopman matrix from trajectory
    let koopmanMatrix = reverseKoopman.constructKoopmanMatrix(trajectory: trajectory)

    if !koopmanMatrix.isEmpty {
        // Compute spectral decomposition
        let (eigenvalues, _) = reverseKoopman.computeSpectralDecomposition()

        // Analyze stability and create findings
        analyzeStabilityFindings(eigenvalues: eigenvalues, cLower: cLower)
    }
}
```

**Detection Capabilities**:
- System instability detection via spectral radius > 1.1
- Poor numerical conditioning (Îº > 100)
- Memory leak detection through growing modes
- Race condition identification

### 2. Storage Security Analysis

**Pattern**: Comprehensive storage security assessment

```swift
private func testInsecureStorage() {
    // Test NSUserDefaults for sensitive data
    testNSUserDefaults()

    // Test file system storage
    testFileSystemStorage()

    // Test Keychain security
    testKeychainSecurity()

    // Test CoreData security
    testCoreDataSecurity()
}
```

**Vulnerability Types**:
- Sensitive data in NSUserDefaults
- Insecure file storage
- Weak Keychain access controls
- CoreData without encryption

### 3. Network Security Analysis

**Pattern**: Multi-layer network security validation

```swift
private func testNetworkSecurity() {
    // Test for insecure HTTP connections
    testInsecureHTTP()

    // Test SSL/TLS configuration
    testSSLConfiguration()

    // Test for sensitive data in logs
    testLogSecurity()
}
```

**Network Vulnerabilities**:
- Insecure HTTP instead of HTTPS
- SSL certificate validation bypass
- Sensitive data in network logs

### 4. Authentication Security Analysis

**Pattern**: Comprehensive authentication mechanism testing

```swift
private func testAuthenticationMechanisms() {
    // Test for weak password policies
    testPasswordPolicies()

    // Test for insecure authentication storage
    testAuthenticationStorage()

    // Test for session management
    testSessionManagement()
}
```

**Authentication Vulnerabilities**:
- Weak password policies
- Insecure token storage
- Poor session management

## Security Finding Structure

### Finding Classification

```swift
struct SecurityFinding: Codable, Identifiable {
    let id: UUID
    let timestamp: Date
    let vulnerabilityType: VulnerabilityType
    let severity: SeverityLevel
    let title: String
    let description: String
    let location: String
    let recommendation: String

    // Mathematical analysis results
    let koopmanStability: Double
    let spectralRadius: Double
    let conditionNumber: Double
    let reconstructionError: Double
    let dominantModes: Int

    // Penetration testing data
    let exploitVector: String?
    let impactAssessment: String
    let cvssScore: Double
}
```

### Severity Levels

```swift
enum SeverityLevel: String, Codable {
    case critical = "Critical"    // System compromise, data breach
    case high = "High"           // Significant security risk
    case medium = "Medium"       // Moderate security concern
    case low = "Low"            // Minor security issue
    case info = "Info"          // Informational finding
}
```

### Vulnerability Types

```swift
enum VulnerabilityType: String, Codable {
    case bufferOverflow = "Buffer Overflow"
    case sqlInjection = "SQL Injection"
    case xss = "Cross-Site Scripting"
    case insecureStorage = "Insecure Storage"
    case weakEncryption = "Weak Encryption"
    case insecureNetwork = "Insecure Network Communication"
    case authenticationBypass = "Authentication Bypass"
    case privilegeEscalation = "Privilege Escalation"
    case memoryLeak = "Memory Leak"
    case raceCondition = "Race Condition"
}
```

## Mathematical Security Analysis

### Koopman-Based Detection

**Spectral Analysis for Security**:
- **Spectral Radius**: System stability indicator
- **Condition Numbers**: Numerical stability assessment
- **Mode Analysis**: Identification of dominant behavioral patterns

```swift
private func analyzeStabilityFindings(eigenvalues: [ComplexNumber], cLower: Double) {
    let spectralRadius = eigenvalues.map { $0.magnitude }.max() ?? 0.0

    // Check for unstable behavior
    if spectralRadius > 1.1 {
        createUnstableSystemFinding(spectralRadius: spectralRadius, cLower: cLower)
    }

    // Check for poor conditioning
    let conditionNumber = eigenvalues.isEmpty ? 0.0 : eigenvalues[0].magnitude / (eigenvalues.last?.magnitude ?? 1.0)
    if conditionNumber > 100 {
        createPoorConditioningFinding(conditionNumber: conditionNumber)
    }
}
```

### IT Assistant Security Analysis

**Specialized IT Assistant Testing**:

```swift
func testITAssistantSecurity() -> [SecurityFinding] {
    findings.removeAll()

    // Analyze system behavior using reverse koopman
    analyzeITAssistantBehavior()

    // Test authentication vulnerabilities
    testITAssistantAuthentication()

    // Test logging security
    testITAssistantLogging()

    // Test API endpoint security
    testITAssistantAPI()

    // Test configuration security
    testITAssistantConfiguration()

    // Test LLM integration security
    testITAssistantLLMSecurity()

    return findings
}
```

## Security Assessment Workflow

### 1. System Analysis Phase

```swift
// Generate system trajectory
let trajectory = reverseKoopman.generateVanDerPolTrajectory(nPoints: 1000)

// Construct koopman matrix
let koopmanMatrix = reverseKoopman.constructKoopmanMatrix(trajectory: trajectory)

// Spectral decomposition
let (eigenvalues, eigenfunctions) = reverseKoopman.computeSpectralDecomposition()

// Lipschitz constant estimation
let (cLower, CUpper) = reverseKoopman.estimateLipschitzConstants(nSamples: 200)
```

### 2. Vulnerability Detection Phase

```swift
// Test each security category
testInsecureStorage()
testNetworkSecurity()
testAuthenticationMechanisms()
testMemoryManagement()
testRaceConditions()
testBufferOverflows()
```

### 3. Analysis and Reporting Phase

```swift
// Generate comprehensive security report
let report = generateSecurityReport()

// Export findings to JSON
let jsonFindings = exportFindingsToJSON()

// Create executive summary
let executiveSummary = createExecutiveSummary()
```

## Security Metrics and KPIs

### Quantitative Security Metrics

```swift
struct SecurityMetrics {
    let totalFindings: Int
    let criticalFindings: Int
    let highFindings: Int
    let mediumFindings: Int
    let lowFindings: Int

    // Koopman-based metrics
    let averageStability: Double
    let spectralRadius: Double
    let conditionNumber: Double

    // Coverage metrics
    let storageCoverage: Double
    let networkCoverage: Double
    let authenticationCoverage: Double
    let memoryCoverage: Double

    var overallSecurityScore: Double {
        // Calculate weighted security score
        let severityWeight = (criticalFindings * 10 + highFindings * 7 + mediumFindings * 4 + lowFindings * 1)
        let coverageWeight = (storageCoverage + networkCoverage + authenticationCoverage + memoryCoverage) / 4.0
        let stabilityWeight = 1.0 / (1.0 + spectralRadius + conditionNumber)

        return (severityWeight * 0.4 + coverageWeight * 0.4 + stabilityWeight * 0.2)
    }
}
```

### Key Performance Indicators

- **MTTD** (Mean Time To Detection): Average time to detect security issues
- **MTTR** (Mean Time To Resolution): Average time to resolve security issues
- **False Positive Rate**: Percentage of incorrect security alerts
- **Coverage Rate**: Percentage of attack surface covered by tests
- **Stability Score**: Koopman-based system stability metric

## Integration with Cloudflare

### Secure Remote Access

```yaml
# Cloudflare Zero Trust Integration
location /api/security {
    auth_request /auth;

    # Rate limiting for security APIs
    limit_req zone=security burst=10 nodelay;

    proxy_pass http://ios-security-api:8080;
    proxy_set_header CF-Connecting-IP $http_cf_connecting_ip;
}

# Authentication endpoint
location = /auth {
    internal;
    proxy_pass https://security.example.com/cdn-cgi/access/get-identity;
    proxy_set_header Host security.example.com;
}
```

### Security Headers and Hardening

```nginx
# Security headers
add_header X-Frame-Options "SAMEORIGIN" always;
add_header X-Content-Type-Options "nosniff" always;
add_header X-XSS-Protection "1; mode=block" always;
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
add_header Referrer-Policy "strict-origin-when-cross-origin" always;

# CSP for security analysis interfaces
add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';" always;
```

## Best Practices

### Security Testing Methodology

1. **Planning**: Define scope, rules of engagement, success criteria
2. **Reconnaissance**: Gather information about the target system
3. **Scanning**: Identify vulnerabilities using automated tools
4. **Gaining Access**: Attempt to exploit identified vulnerabilities
5. **Maintaining Access**: Ensure persistent access if authorized
6. **Analysis**: Document findings with mathematical validation
7. **Reporting**: Generate comprehensive security reports
8. **Cleanup**: Remove all traces of testing activities

### Mathematical Validation

- **Koopman Operators**: System stability and behavior analysis
- **Spectral Methods**: Frequency domain analysis of security events
- **Statistical Analysis**: False positive/negative rate calculation
- **Risk Assessment**: Quantitative vulnerability scoring

### Documentation and Compliance

- **Finding Documentation**: Detailed evidence collection
- **Risk Assessment**: Business impact analysis
- **Remediation Planning**: Actionable improvement recommendations
- **Compliance Mapping**: Alignment with security frameworks (NIST, OWASP, etc.)

This framework provides a mathematically rigorous approach to security analysis, combining traditional penetration testing with advanced dynamical systems analysis for comprehensive security assessment.