---
description: "Multi-language development patterns, cross-platform integration, and language selection guidelines"
alwaysApply: false
---
# ðŸŒ Multi-Language Development Patterns

This rule establishes the multi-language development patterns, cross-platform integration strategies, and language selection guidelines for the scientific computing toolkit.

## ðŸŽ¯ **Language Selection Framework**

### **Primary Language Matrix**
```python
LANGUAGE_MATRIX = {
    "python": {
        "strengths": ["Scientific computing ecosystem", "Rapid prototyping", "Data analysis"],
        "use_cases": ["Research prototyping", "Data processing", "Visualization"],
        "performance": "Medium-High (with NumPy/SciPy)",
        "ecosystem": "Excellent (scientific libraries)",
        "learning_curve": "Low",
        "deployment": "Cross-platform"
    },
    "java": {
        "strengths": ["Enterprise robustness", "Security frameworks", "Cross-platform JVM"],
        "use_cases": ["Production systems", "Security testing", "Enterprise integration"],
        "performance": "High",
        "ecosystem": "Excellent (enterprise libraries)",
        "learning_curve": "Medium",
        "deployment": "JVM platforms"
    },
    "swift": {
        "strengths": ["iOS/macOS native", "Performance", "Safety"],
        "use_cases": ["Mobile applications", "Apple ecosystem", "System programming"],
        "performance": "High",
        "ecosystem": "Good (Apple platforms)",
        "learning_curve": "Medium",
        "deployment": "Apple platforms"
    },
    "mojo": {
        "strengths": ["High-performance computing", "Python interoperability", "Systems programming"],
        "use_cases": ["Performance-critical algorithms", "GPU computing", "Systems optimization"],
        "performance": "Very High",
        "ecosystem": "Emerging",
        "learning_curve": "Medium-High",
        "deployment": "Cross-platform with Python integration"
    }
}
```

### **Language Selection Algorithm**
```python
def select_optimal_language(requirements: Dict[str, Any]) -> str:
    """
    Select optimal programming language based on project requirements.

    Args:
        requirements: Dictionary containing project requirements

    Returns:
        Optimal language recommendation
    """

    # Performance requirements
    if requirements.get("performance_critical", False):
        if requirements.get("gpu_acceleration", False):
            return "mojo"  # GPU computing support
        elif requirements.get("low_level_optimization", False):
            return "mojo"  # Systems programming capabilities
        else:
            return "java"  # High-performance JVM

    # Platform requirements
    platform = requirements.get("target_platform", "cross_platform")
    if platform == "ios" or platform == "macos":
        return "swift"  # Native Apple ecosystem
    elif platform == "enterprise":
        return "java"  # Enterprise robustness
    elif platform == "scientific_research":
        return "python"  # Scientific ecosystem

    # Development speed requirements
    if requirements.get("rapid_prototyping", False):
        return "python"  # Fast development cycle

    # Integration requirements
    if requirements.get("python_integration", False):
        return "mojo"  # Seamless Python interoperability

    # Default to Python for general scientific computing
    return "python"
```

## ðŸ”§ **Cross-Language Integration Patterns**

### **Python â†” Java Integration**
```python
# Python calling Java (JPype/JPype2)
import jpype
import jpype.imports

def initialize_java_bridge():
    """Initialize Python-Java bridge."""
    # Start JVM
    jpype.startJVM(
        jpype.getDefaultJVMPath(),
        "-ea",
        "-Djava.class.path=Corpus/out"
    )

    # Import Java classes
    from qualia import JavaPenetrationTesting
    from qualia import ReverseKoopmanOperator

    return JavaPenetrationTesting, ReverseKoopmanOperator

def process_with_java_bridge(python_data: Dict[str, Any]) -> Dict[str, Any]:
    """Process data using Java frameworks from Python."""

    JavaPenetrationTesting, ReverseKoopmanOperator = initialize_java_bridge()

    # Create Java objects
    java_tester = JavaPenetrationTesting()
    koopman_op = ReverseKoopmanOperator()

    # Convert Python data to Java-compatible format
    java_data = convert_python_to_java(python_data)

    # Execute Java processing
    java_result = java_tester.runComprehensiveTesting(java_data)

    # Convert Java result back to Python
    python_result = convert_java_to_python(java_result)

    # Shutdown JVM
    jpype.shutdownJVM()

    return python_result
```

```java
// Java calling Python (Jython/JPy)
import org.python.core.PyObject;
import org.python.core.PyString;
import org.python.util.PythonInterpreter;

public class PythonBridge {
    private PythonInterpreter interpreter;

    public PythonBridge() {
        this.interpreter = new PythonInterpreter();
        this.interpreter.exec("import sys");
        this.interpreter.exec("sys.path.append('data_output')");
    }

    public PyObject executePythonFunction(String module, String function,
                                        Map<String, Object> parameters) {
        // Import Python module
        interpreter.exec("from " + module + " import " + function);

        // Convert Java parameters to Python
        for (Map.Entry<String, Object> entry : parameters.entrySet()) {
            interpreter.set(entry.getKey(), entry.getValue());
        }

        // Execute Python function
        PyObject result = interpreter.eval(function + "()");

        return result;
    }

    public void processWithPythonBridge() {
        Map<String, Object> params = new HashMap<>();
        params.put("dataset_name", "rheology");
        params.put("processing_options", Map.of("validate", true));

        PyObject result = executePythonFunction(
            "data_flow_processor",
            "process_rheology_dataset",
            params
        );

        // Process Python result in Java
        System.out.println("Python processing result: " + result);
    }
}
```

### **Swift â†” Python Integration**
```swift
// Swift calling Python (PythonKit)
import PythonKit

func initializePythonBridge() -> PythonObject {
    // Initialize Python interpreter
    let sys = Python.import("sys")
    sys.path.append("data_output")

    // Import Python modules
    let dataProcessor = Python.import("data_flow_processor")
    let integrationRunner = Python.import("integration_runner")

    return PythonObject([
        "data_processor": dataProcessor,
        "integration_runner": integrationRunner
    ])
}

func processWithPythonBridge(swiftData: [String: Any]) async throws -> [String: Any] {
    let pythonBridge = initializePythonBridge()

    // Convert Swift data to Python
    let pythonData = convertSwiftToPython(swiftData)

    // Execute Python processing
    let result = pythonBridge.data_processor.process_rheology_dataset(pythonData)

    // Convert Python result back to Swift
    let swiftResult = convertPythonToSwift(result)

    return swiftResult
}
```

```python
# Python calling Swift (via subprocess or native bridge)
import subprocess
import json

def execute_swift_processing(dataset_name: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
    """Execute Swift processing from Python."""

    # Prepare parameters for Swift
    swift_params = {
        "dataset_name": dataset_name,
        "parameters": parameters,
        "output_format": "json"
    }

    # Execute Swift binary
    cmd = ["swift", "run", "UOIFCore", json.dumps(swift_params)]

    try:
        result = subprocess.run(
            cmd,
            cwd="Farmer",
            capture_output=True,
            text=True,
            timeout=60
        )

        if result.returncode == 0:
            return json.loads(result.stdout)
        else:
            logger.error(f"Swift execution failed: {result.stderr}")
            return {"status": "error", "error": result.stderr}

    except subprocess.TimeoutExpired:
        logger.error("Swift processing timed out")
        return {"status": "error", "error": "Processing timeout"}

    except Exception as e:
        logger.error(f"Swift execution error: {e}")
        return {"status": "error", "error": str(e)}
```

### **Mojo â†” Python Integration**
```mojo
# Mojo calling Python (native Python interoperability)
from python import Python

fn process_with_python_bridge(dataset: Dict[String, Any]) -> Dict[String, Any]:
    """Process data using Python libraries from Mojo."""

    # Import Python modules
    let data_processor = Python.import("data_flow_processor")
    let numpy = Python.import("numpy")

    # Convert Mojo data to Python
    let python_data = convert_mojo_to_python(dataset)

    # Execute Python processing with high performance
    let result = data_processor.CorpusDataFlowProcessor().process_rheology_dataset(python_data)

    # Convert Python result back to Mojo
    let mojo_result = convert_python_to_mojo(result)

    return mojo_result
```

```python
# Python calling Mojo (via subprocess or compiled binary)
import subprocess
import json

def execute_mojo_accelerated_processing(data: Dict[str, Any]) -> Dict[str, Any]:
    """Execute Mojo-accelerated processing from Python."""

    # Serialize data for Mojo
    input_data = json.dumps(data)

    # Execute Mojo binary
    cmd = ["./mojo_processor", input_data]

    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=30
        )

        if result.returncode == 0:
            return json.loads(result.stdout)
        else:
            logger.error(f"Mojo execution failed: {result.stderr}")
            return {"status": "error", "error": result.stderr}

    except Exception as e:
        logger.error(f"Mojo execution error: {e}")
        return {"status": "error", "error": str(e)}
```

## ðŸ—ï¸ **Cross-Platform Architecture Patterns**

### **Unified API Design**
```python
# Unified API across all languages
class UnifiedScientificAPI:
    """Unified API for cross-language scientific computing."""

    def __init__(self, language: str = "auto"):
        self.language = language
        self._initialize_bridge()

    def _initialize_bridge(self):
        """Initialize appropriate language bridge."""
        if self.language == "java" or (self.language == "auto" and self._detect_java()):
            self.bridge = JavaBridge()
        elif self.language == "swift" or (self.language == "auto" and self._detect_swift()):
            self.bridge = SwiftBridge()
        elif self.language == "mojo" or (self.language == "auto" and self._detect_mojo()):
            self.bridge = MojoBridge()
        else:
            self.bridge = NativePythonBridge()

    def process_dataset(self, dataset_name: str, parameters: Dict[str, Any] = None) -> Dict[str, Any]:
        """Unified dataset processing across all languages."""
        return self.bridge.process_dataset(dataset_name, parameters or {})

    def get_performance_metrics(self) -> Dict[str, float]:
        """Get performance metrics from current bridge."""
        return self.bridge.get_performance_metrics()

    def validate_results(self, results: Dict[str, Any]) -> bool:
        """Validate results across language implementations."""
        return self.bridge.validate_results(results)
```

### **Language-Agnostic Data Formats**
```json
{
  "unified_dataset_format": {
    "metadata": {
      "dataset_name": "rheology_experimental_data",
      "language_processed": "python",
      "processing_timestamp": "2024-01-26T12:00:00Z",
      "schema_version": "1.0"
    },
    "data": {
      "measurements": [
        {"shear_rate": 1.0, "viscosity": 1000.0, "temperature": 25.0},
        {"shear_rate": 5.0, "viscosity": 800.0, "temperature": 25.0}
      ],
      "units": {
        "shear_rate": "1/s",
        "viscosity": "PaÂ·s",
        "temperature": "Celsius"
      }
    },
    "processing_parameters": {
      "algorithm": "levenberg_marquardt",
      "convergence_threshold": 0.9987,
      "max_iterations": 1000
    },
    "results": {
      "parameters": {
        "yield_stress": 0.0,
        "consistency_index": 850.0,
        "flow_behavior_index": 0.82
      },
      "statistics": {
        "r_squared": 0.987,
        "rmse": 0.023,
        "confidence_intervals": {
          "yield_stress": [0.0, 0.0],
          "consistency_index": [820.0, 880.0],
          "flow_behavior_index": [0.79, 0.85]
        }
      }
    },
    "validation": {
      "cross_language_consistency": true,
      "performance_baseline_met": true,
      "accuracy_requirements_satisfied": true
    }
  }
}
```

## ðŸš€ **Performance Optimization Patterns**

### **Language-Specific Optimizations**
```python
# Python optimization patterns
class PythonOptimizer:
    """Python-specific performance optimizations."""

    def vectorize_computations(self, data: np.ndarray) -> np.ndarray:
        """Vectorize operations using NumPy."""
        # Replace loops with vectorized operations
        return np.vectorize(self.expensive_function)(data)

    def use_numba_jit(self, func):
        """Apply Numba JIT compilation."""
        from numba import jit
        return jit(nopython=True)(func)

    def parallel_processing(self, data: List[Any]) -> List[Any]:
        """Utilize multiprocessing for CPU-bound tasks."""
        import multiprocessing as mp
        with mp.Pool() as pool:
            return pool.map(self.process_item, data)
```

```java
// Java optimization patterns
public class JavaOptimizer {
    public double[] vectorizedComputation(double[] data) {
        // Use efficient array operations
        double[] result = new double[data.length];
        Arrays.parallelSetAll(result, i -> expensiveFunction(data[i]));
        return result;
    }

    public CompletableFuture<double[]> asyncProcessing(double[] data) {
        return CompletableFuture.supplyAsync(() -> {
            return vectorizedComputation(data);
        });
    }
}
```

```swift
// Swift optimization patterns
class SwiftOptimizer {
    func vectorizedComputation(_ data: [Double]) -> [Double] {
        // Use Swift's high-performance array operations
        return data.map { expensiveFunction($0) }
    }

    func concurrentProcessing(_ data: [Double]) async -> [Double] {
        // Utilize Swift concurrency
        return await withTaskGroup(of: Double.self) { group in
            for value in data {
                group.addTask {
                    return self.expensiveFunction(value)
                }
            }

            var results: [Double] = []
            for await result in group {
                results.append(result)
            }
            return results
        }
    }
}
```

### **Cross-Language Performance Benchmarking**
```python
class PerformanceBenchmarker:
    """Cross-language performance benchmarking."""

    def benchmark_language_implementations(self, implementations: Dict[str, Callable]) -> Dict[str, Dict[str, float]]:
        """Benchmark same algorithm across different languages."""

        results = {}
        test_data = self.generate_test_data()

        for language, implementation in implementations.items():
            logger.info(f"Benchmarking {language} implementation...")

            # Time execution
            start_time = time.time()
            result = implementation(test_data)
            execution_time = time.time() - start_time

            # Measure memory usage
            memory_usage = self.measure_memory_usage(implementation, test_data)

            # Validate correctness
            is_correct = self.validate_result(result)

            results[language] = {
                "execution_time": execution_time,
                "memory_usage": memory_usage,
                "correctness": is_correct,
                "performance_score": self.calculate_performance_score(execution_time, memory_usage, is_correct)
            }

        return results

    def generate_performance_report(self, benchmark_results: Dict[str, Dict[str, float]]) -> str:
        """Generate comprehensive performance report."""
        # Implementation for detailed performance analysis
        pass
```

## ðŸ“‹ **Development Workflow Standards**

### **Multi-Language Project Structure**
```
scientific-computing-toolkit/
â”œâ”€â”€ python/                          # Python implementations
â”‚   â”œâ”€â”€ scientific_computing_tools/
â”‚   â”œâ”€â”€ data_output/
â”‚   â””â”€â”€ requirements.txt
â”œâ”€â”€ java/                           # Java implementations
â”‚   â”œâ”€â”€ Corpus/qualia/
â”‚   â”œâ”€â”€ build.sh
â”‚   â””â”€â”€ Dockerfile
â”œâ”€â”€ swift/                          # Swift implementations
â”‚   â”œâ”€â”€ Farmer/
â”‚   â”œâ”€â”€ Package.swift
â”‚   â””â”€â”€ Sources/UOIFCore/
â”œâ”€â”€ mojo/                           # Mojo implementations
â”‚   â”œâ”€â”€ high_performance_modules/
â”‚   â””â”€â”€ build_config.json
â”œâ”€â”€ shared/                         # Cross-language resources
â”‚   â”œâ”€â”€ schemas/                    # Data format schemas
â”‚   â”œâ”€â”€ configs/                    # Configuration files
â”‚   â””â”€â”€ docs/                       # Unified documentation
â””â”€â”€ integration/                    # Cross-language integration
    â”œâ”€â”€ bridges/                    # Language bridge implementations
    â”œâ”€â”€ tests/                      # Cross-language tests
    â””â”€â”€ benchmarks/                 # Performance comparisons
```

### **Version Management**
```json
{
  "cross_language_versions": {
    "python": {
      "version": "3.8+",
      "key_packages": ["numpy==1.24.0", "scipy==1.10.0"],
      "compatibility_matrix": {
        "java": "11+",
        "swift": "5.0+",
        "mojo": "0.1+"
      }
    },
    "java": {
      "version": "11+",
      "key_packages": ["qualia-framework", "junit"],
      "compatibility_matrix": {
        "python": "3.8+",
        "swift": "5.0+"
      }
    }
  }
}
```

## ðŸ”§ **Integration Testing Standards**

### **Cross-Language Test Framework**
```python
class CrossLanguageTestSuite:
    """Comprehensive testing across all supported languages."""

    def __init__(self):
        self.test_results = {}
        self.language_bridges = self.initialize_bridges()

    def initialize_bridges(self) -> Dict[str, Any]:
        """Initialize bridges to all supported languages."""
        return {
            "python": NativePythonBridge(),
            "java": JavaBridge(),
            "swift": SwiftBridge(),
            "mojo": MojoBridge()
        }

    def run_cross_language_tests(self) -> Dict[str, Any]:
        """Run identical tests across all language implementations."""

        test_cases = [
            "rheology_parameter_extraction",
            "biometric_confidence_calculation",
            "optical_depth_enhancement",
            "biological_transport_modeling"
        ]

        for test_case in test_cases:
            logger.info(f"Running cross-language test: {test_case}")

            results = {}
            for language, bridge in self.language_bridges.items():
                try:
                    result = bridge.run_test(test_case)
                    results[language] = {
                        "status": "passed",
                        "result": result,
                        "execution_time": result.get("execution_time", 0)
                    }
                except Exception as e:
                    results[language] = {
                        "status": "failed",
                        "error": str(e)
                    }

            # Validate cross-language consistency
            self.validate_cross_language_consistency(test_case, results)
            self.test_results[test_case] = results

        return self.test_results

    def validate_cross_language_consistency(self, test_case: str, results: Dict[str, Any]):
        """Validate that all language implementations produce consistent results."""
        # Implementation for cross-language result validation
        pass
```

## ðŸŽ¯ **Best Practices**

### **Language Selection Guidelines**
1. **Python**: Scientific prototyping, data analysis, research exploration
2. **Java**: Production systems, enterprise integration, security frameworks
3. **Swift**: iOS/macOS applications, Apple ecosystem integration
4. **Mojo**: High-performance computing, GPU acceleration, Python interoperability

### **Integration Best Practices**
1. **Unified APIs**: Consistent interfaces across all languages
2. **Data Format Standardization**: Language-agnostic data exchange formats
3. **Performance Benchmarking**: Regular cross-language performance comparisons
4. **Error Handling**: Consistent error reporting and recovery across languages

### **Development Best Practices**
1. **Code Consistency**: Follow language-specific conventions and idioms
2. **Documentation**: Comprehensive documentation in all languages
3. **Testing**: Cross-language test suites with identical test cases
4. **Version Management**: Synchronized versioning across all language implementations

This multi-language development framework ensures seamless integration, optimal performance, and consistent behavior across Python, Java, Swift, and Mojo implementations.